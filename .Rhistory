C <- C + C_ell[[i]]/L
}
C_ell <- list()
for(i in 1:L){
A <- diag(c((1 - i/(L+1)), 1/(L+1), rep(1, 3))) # Scaling (Theorem 1)
C_tmp <- C_bass(mod, prior=rho[[i]])
C_ell[[i]] <- A%*%C_tmp%*%t(A)
}
C_ell[[1]]
C <- matrix(0, nrow=p, ncol=p)
for(i in 1:L){
C <- C + C_ell[[i]]/L
}
round(C, 3)
C_ell <- list()
for(i in 1:L){
A <- diag(c((1 - i/(L+1)), 1/(L+1), rep(1, 3))) # Scaling (Theorem 1)
C_tmp <- C_bass(mod, prior=rho[[i]])
C_ell[[i]] <- A%*%C_tmp%*%t(A)
}
Ctrue2 <- matrix(0, nrow=p, ncol=p)
Ctrue2[1:2, 1:2] <- matrix(c(1710, 741,
741, 322) / 540,
nrow=2, byrow=TRUE)
round(Ctrue2, 2)
L <- 5 # Number of mixture components
rho <- list()
for(i in 1:L){
rho[[i]] <- list(
rho1=list(dist="uniform", trunc=c(i/(L+1), 1)),
rho2=list(dist="uniform", trunc=c((i-1), i)/(L+1)),
rho3=list(dist="uniform", trunc=c(0,1)),
rho4=list(dist="uniform", trunc=c(0,1)),
rho5=list(dist="uniform", trunc=c(0,1))
)
}
C_ell <- list()
for(i in 1:L){
A <- diag(c((1 - i/(L+1)), 1/(L+1), rep(1, 3))) # Scaling (Theorem 1)
C_tmp <- C_bass(mod, prior=rho[[i]])
C_ell[[i]] <- A%*%C_tmp%*%t(A)
}
C <- matrix(0, nrow=p, ncol=p)
for(i in 1:L){
C <- C + C_ell[[i]]/L
}
round(C, 3)
C <- matrix(0, nrow=p, ncol=p)
for(i in 1:L){
C <- C + C_ell[[i]]
}
round(C, 3)
L <- 50 # Number of mixture components
rho <- list()
for(i in 1:L){
rho[[i]] <- list(
rho1=list(dist="uniform", trunc=c(i/(L+1), 1)),
rho2=list(dist="uniform", trunc=c((i-1), i)/(L+1)),
rho3=list(dist="uniform", trunc=c(0,1)),
rho4=list(dist="uniform", trunc=c(0,1)),
rho5=list(dist="uniform", trunc=c(0,1))
)
}
C_ell <- list()
for(i in 1:L){
A <- diag(c((1 - i/(L+1)), 1/(L+1), rep(1, 3))) # Scaling (Theorem 1)
C_tmp <- C_bass(mod, prior=rho[[i]])
C_ell[[i]] <- A%*%C_tmp%*%t(A)
}
C <- matrix(0, nrow=p, ncol=p)
for(i in 1:L){
C <- C + C_ell[[i]]
}
round(C, 3)
C <- matrix(0, nrow=p, ncol=p)
for(i in 1:L){
C <- C + C_ell[[i]]/L
}
round(C, 3)
# Load libraries
library(concordance)
library(lhs)
library(BASS)
library(activegp)
library(hetGP)
library(tictoc)
# Define the simple polynomial function
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Case 1. Unconstrained prior over Unif(0, 2)^2
Ctrue  <- matrix(c(32/3, 47/9, 47/9, 116/45), nrow=2, byrow=TRUE)
Ctrue
1710/540
19/6
# Case 2. Constrained prior, uniform over [0,1]^2 * 1(x_1 > x_2)
C2_true <- matrix(c(19/6, 247/180, 247/180, 161/270), nrow=2, byrow=TRUE)
C2_true
741/540
# Estimate with MC
measure <- function(){
x <- c(-Inf, 0)
while(x[1] <= x[2]){
x <- runif(2, 0, 1)
}
return(x)
}
C_mc(f, measure, nmc=1e5)
# Simulate data and train BASS model
X <- maximinLHS(500, 2)
Y <- apply(X, 1, f)
mod <- bass(X, Y)
C <- matrix(0, nrow=p, ncol=p)
for(i in 1:L){
C <- C + C_ell[[i]]*wt[ell]
}
C_ell <- list()
wt <- rep(NA, L)
for(i in 1:L){
A <- diag(c((1 - i/(L+1)), 1/(L+1), rep(1, 3))) # Scaling (Theorem 1)
C_ell[[i]] <- C_bass(mod, prior=rho[[i]])
wt[ell] <- (1 - ell/(L+1))*(1/(L+1))
}
C_ell <- list()
wt <- rep(NA, L)
for(i in 1:L){
A <- diag(c((1 - i/(L+1)), 1/(L+1), rep(1, 3))) # Scaling (Theorem 1)
C_ell[[i]] <- C_bass(mod, prior=rho[[i]])
wt[i] <- (1 - ell/(L+1))*(1/(L+1))
}
C <- matrix(0, nrow=p, ncol=p)
for(i in 1:L){
C <- C + C_ell[[i]]*wt[ell]
}
C <- matrix(0, nrow=p, ncol=p)
for(i in 1:L){
C <- C + C_ell[[i]]*wt[i]
}
C_ell <- list()
wt <- rep(NA, L)
for(i in 1:L){
A <- diag(c((1 - i/(L+1)), 1/(L+1), rep(1, 3))) # Scaling (Theorem 1)
C_ell[[i]] <- C_bass(mod, prior=rho[[i]])
wt[i] <- (1 - ell/(L+1))*(1/(L+1))
}
C_ell <- list()
wt <- rep(NA, L)
for(i in 1:L){
A <- diag(c((1 - i/(L+1)), 1/(L+1), rep(1, 3))) # Scaling (Theorem 1)
C_ell[[i]] <- C_bass(mod, prior=rho[[i]])
wt[i] <- (1 - i/(L+1))*(1/(L+1))
}
wt
C <- matrix(0, nrow=p, ncol=p)
for(i in 1:L){
C <- C + C_ell[[i]]*wt[i]
}
C_ell <- list()
wt <- rep(NA, L)
for(i in 1:L){
A <- diag(c((1 - i/(L+1)), 1/(L+1), rep(1, 3))) # Scaling (Theorem 1)
C_ell[[i]] <- C_bass(mod, prior=rho[[i]])
wt[i] <- (1 - i/(L+1))*(1/(L+1))
}
C_ell[[1]]
#devtools::install_github("knrumsey/concordance")
library(concordance)
library(BASS)
mod <- bass(X, y, verbose=FALSE)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
n <- 500
p <- 5
X <- matrix(runif(n*p), ncol=p)
y <- apply(X, 1, f)
Ctrue <- matrix(0, nrow=p, ncol=p)
Ctrue[1:2, 1:2] <- matrix(c(120, 50,
50, 21) / 45,
nrow=2, byrow=TRUE)
round(Ctrue, 2)
#devtools::install_github("knrumsey/concordance")
library(concordance)
library(BASS)
mod <- bass(X, y, verbose=FALSE)
C   <- C_bass(mod)
round(C, 3)
L <- 15 # Number of mixture components
rho <- list()
for(i in 1:L){
rho[[i]] <- list(
rho1=list(dist="uniform", trunc=c(i/(L+1), 1)),
rho2=list(dist="uniform", trunc=c((i-1), i)/(L+1)),
rho3=list(dist="uniform", trunc=c(0,1)),
rho4=list(dist="uniform", trunc=c(0,1)),
rho5=list(dist="uniform", trunc=c(0,1))
)
}
C_ell <- list()
wt <- rep(NA, L)
for(i in 1:L){
C_ell[[i]] <- C_bass(mod, prior=rho[[i]])
wt[i] <- (1 - i/(L+1))*(1/(L+1))
}
C <- matrix(0, nrow=2, ncol=2)
for(i in 1:L){
C <- C + C_ell[[i]]*wt[i]
}
C <- matrix(0, nrow=p, ncol=p)
for(i in 1:L){
C <- C + C_ell[[i]]*wt[i]
}
round(C, 3)
L <- 50 # Number of mixture components
rho <- list()
for(i in 1:L){
rho[[i]] <- list(
rho1=list(dist="uniform", trunc=c(i/(L+1), 1)),
rho2=list(dist="uniform", trunc=c((i-1), i)/(L+1)),
rho3=list(dist="uniform", trunc=c(0,1)),
rho4=list(dist="uniform", trunc=c(0,1)),
rho5=list(dist="uniform", trunc=c(0,1))
)
}
C_ell <- list()
wt <- rep(NA, L)
for(i in 1:L){
C_ell[[i]] <- C_bass(mod, prior=rho[[i]])
wt[i] <- (1 - i/(L+1))*(1/(L+1))
}
C <- matrix(0, nrow=p, ncol=p)
for(i in 1:L){
C <- C + C_ell[[i]]*wt[i]
}
round(C, 3)
C <- matrix(0, nrow=p, ncol=p)
for(i in 1:L){
C <- C + C_ell[[i]]*wt[i]
}
round(C, 3)
C_ell <- list()
wt <- rep(NA, L)
for(i in 1:L){
C_ell[[i]] <- C_bass(mod, prior=rho[[i]])
wt[i] <- (1 - i/(L+1))*(1/(L+1))
}
sum(wt)
C_ell <- list()
wt <- rep(NA, L)
for(i in 1:L){
C_ell[[i]] <- C_bass(mod, prior=rho[[i]])
wt[i] <- (1 - i/(L+1))*(1/(L+1))
}
wt <- wt/sum(wt)
C <- matrix(0, nrow=p, ncol=p)
for(i in 1:L){
C <- C + C_ell[[i]]*wt[i]
}
round(C, 3)
ell = 1:L
(1 - ell/(L+1))*(1/(L+1))
sum((1 - ell/(L+1))*(1/(L+1)))
L <- 15 # Number of mixture components
rho <- list()
for(i in 1:L){
rho[[i]] <- list(
rho1=list(dist="uniform", trunc=c(i/(L+1), 1)),
rho2=list(dist="uniform", trunc=c((i-1), i)/(L+1)),
rho3=list(dist="uniform", trunc=c(0,1)),
rho4=list(dist="uniform", trunc=c(0,1)),
rho5=list(dist="uniform", trunc=c(0,1))
)
}
C_ell <- list()
wt <- rep(NA, L)
for(i in 1:L){
C_ell[[i]] <- C_bass(mod, prior=rho[[i]])
wt[i] <- (1 - i/(L+1))*(1/(L+1))
}
wt <- wt/sum(wt)
C <- matrix(0, nrow=p, ncol=p)
for(i in 1:L){
C <- C + C_ell[[i]]*wt[i]
}
round(C, 3)
C <- matrix(0, nrow=p, ncol=p)
for(i in 1:L){
C <- C + C_ell[[i]]*wt[i]
}
round(C, 3)
L
C <- matrix(0, nrow=p, ncol=p)
for(i in 1:L){
C <- C + C_ell[[i]]*wt[i]
}
round(C, 3)
n <- 500
p <- 6
X <- matrix(runif(n*p), ncol=p)
A <- matrix(c(12, 9, 6, 1, 1, 1,
1, 1, 1, 15, 6, 6) / 3,
nrow=p, ncol=2)
Z <- X%*%A
y <- apply(Z, 1, f)
A
n <- 500
p <- 6
X <- matrix(runif(n*p), ncol=p)
A <- matrix(c(12, 9, 6, 1,  1, 1,
1,  1, 1, 15, 6, 6) / 3,
nrow=p, ncol=2)
Z <- X%*%A
y <- apply(Z, 1, f)
mod <- bass(X, y)
C   <- C_bass(mod)
rmspe
q     <- 2
mod_q <- bass(X%*%W[,1:i], y)
W <- eigen(C)$vectors
q     <- 2
mod_q <- bass(X%*%W[,1:i], y)
q     <- 2
mod_q <- bass(X%*%W[,1:q], y)
rmspe <- sqrt(mean((mod_q$yhat.mean - y)^2))
# Percent of SD Explained
round((1 - rmspe/sd(y))*100, 3)
q     <- 2
mod_q <- bass(X%*%W[,1:q], y, verbose=FALSE)
rmspe <- sqrt(mean((mod_q$yhat.mean - y)^2))
# Percent of SD Explained
round((1 - rmspe/sd(y))*100, 3)
# Load libraries
library(concordance)
library(lhs)
library(BASS)
library(activegp)
library(hetGP)
library(tictoc)
# Define the simple polynomial function
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Case 1. Unconstrained prior over Unif(0, 2)^2
Ctrue  <- matrix(c(32/3, 47/9, 47/9, 116/45), nrow=2, byrow=TRUE)
# Estimate with MC
measure <- function() runif(2, 0, 2)
C_mc(f, measure, nmc=1e5)
# Simulate data from model (unconstrained prior)
X <- 2*maximinLHS(500, 2)
Y <- apply(X, 1, f)
# Estimate Ctrue with bass
mod <- bass(X, Y)
C1 <- C_bass(mod)
# Case 2. Constrained prior, uniform over [0,1]^2 * 1(x_1 > x_2)
C2_true <- matrix(c(19/6, 247/180, 247/180, 161/270), nrow=2, byrow=TRUE)
# Estimate with MC
measure <- function(){
x <- c(-Inf, 0)
while(x[1] <= x[2]){
x <- runif(2, 0, 1)
}
return(x)
}
C_mc(f, measure, nmc=1e5)
# Simulate data and train BASS model
X <- maximinLHS(500, 2)
Y <- apply(X, 1, f)
mod <- bass(X, Y)
# Approximate contraints using mixture of L boxes
L_vec <- c(1, 2, 3, 5, 10, 20, 30, 50, 100)
err_vec <- rep(NA, length(L_vec))
tim_vec <- rep(NA, length(L_vec))
for(iii in seq_along(L_vec)){
L <- L_vec[iii]
C_list <- list()
C2 <- matrix(0, nrow=2, ncol=2)
wt <- rep(NA, L)
tic()
for(ell in 1:L){
pr <- list()
pr[[1]] <- list(dist="uniform", trunc=c(ell, L+1)/(L+1))
pr[[2]] <- list(dist="uniform", trunc=c(ell-1, ell)/(L+1))
C_list[[ell]] <- C_bass(mod, prior=pr)
wt[ell] <- (1 - ell/(L+1))*(1/(L+1))
}
wt <- wt/sum(wt) # why didn't i have this before?
for(ell in 1:L){
C2 <- C2 + C_list[[ell]]*wt[ell]
}
tt = toc()
err_vec[iii] <- sqrt(sum((C2/sum(wt) - C2_true)^2))/2
tim_vec[iii] <- tt$toc - tt$tic
print(iii)
}
par(mfrow=c(1,1))
par(mar=c(5.1, 4.1, 4.1, 5.1), xpd=FALSE)
plot(L_vec, err_vec, ylim=c(0, max(err_vec)), pch=16, cex=2, xlab="Number of Mixture Components", ylab="Error", cex.lab=1.2, xaxt='n', type='o')
lines(L_vec, tim_vec/max(tim_vec)*max(err_vec), lty=2)
points(L_vec, tim_vec/max(tim_vec)*max(err_vec), pch=15, cex=2)
axis(1, L_vec, L_vec)
ttt = tim_vec
axis(4, seq(0, 7, by=1)/max(tim_vec)*max(err_vec), seq(0, 7, by=1))
mtext("Time (seconds)", side=4, line=3, cex=1.2)
abline(h=0)
legend('top', c("Error", "Runtime"), lty=1:2, pch=16:15, cex=2, bty='n')
png("figs/constrained_poly_plot.png",
height=5, width=8, units="in", res=300)
par(mfrow=c(1,1))
par(mar=c(5.1, 4.1, 4.1, 5.1), xpd=FALSE)
plot(L_vec, err_vec, ylim=c(0, max(err_vec)), pch=16, cex=2, xlab="Number of Mixture Components", ylab="Error", cex.lab=1.2, xaxt='n', type='o')
lines(L_vec, tim_vec/max(tim_vec)*max(err_vec), lty=2)
points(L_vec, tim_vec/max(tim_vec)*max(err_vec), pch=15, cex=2)
axis(1, L_vec, L_vec)
ttt = tim_vec
axis(4, seq(0, 7, by=1)/max(tim_vec)*max(err_vec), seq(0, 7, by=1))
mtext("Time (seconds)", side=4, line=3, cex=1.2)
abline(h=0)
legend('top', c("Error", "Runtime"), lty=1:2, pch=16:15, cex=2, bty='n')
dev.off()
mycol <- function(yy, nn){
yy <- (yy-min(yy))/diff(range(yy))
1 + floor(yy*(nn-1))
}
if(require("rgl"))
print("hey")
source("R/setup.R", echo=FALSE)
# A simple function of two variables
f <- function(x){
x[1]^2 + x[1]*x[2] + x[2]^3/9
}
# Evaluate "g()" by projecting 6-dims down to 2-dim
N <- 500
p <- 6
X <- lhs::maximinLHS(N, p)
A <- matrix(c(4, 3, 2, 1/3, 1/3, 1/3,
1/3, 1/3, 1/3, 5, 2, 2), nrow=p, ncol=2)
Z <- X%*%A
y <- apply(Z, 1, f)
# Fit model and get active directions
mod <- bass(X, y)
C <- C_bass(mod)
W <- eigen(C)$vectors
# Get RSMPE values for various projection dimension
rmspe <- rep(NA, 6)
for(i in 1:6){
mod_tmp <- bass(X%*%W[,1:i], y)
rmspe[i] <- sqrt(mean((mod_tmp$yhat.mean - y)^2))
}
pct_expl <- (1 - rmspe/sd(y)) * 100
sqrt_eval <- sqrt(eigen(C)$values)
# Make Table
tab <- matrix(NA, nrow=2, ncol=6)
rownames(tab) <- c("Square Root Eigenvalue", "Pct of SD Explained")
tab[1,] <- sqrt_eval/max(sqrt_eval)
tab[2,] <- (1 - rmspe/sd(y))*100
stargazer::stargazer(tab)
stargazer::stargazer(tab, type="text")
bob <- RColorBrewer::brewer.pal(11, "RdBu")
plot(X%*%W[,1], y, xlab="First active direction", ylab="Model output",
pch=21, bg=bob[mycol(y, length(bob))], col="black")
plot3d(X%*%W[,1], X%*%W[,2], y,
xlab="First active direction",
ylab="Second active direction",
zlab="Model output",
col=bob[mycol(y, length(bob))], size=0.8, type=c("s"))
options(rgl.printRglwidget = TRUE)
options(rgl.printRglwidget = TRUE)
plot3d(X%*%W[,1], X%*%W[,2], y,
xlab="First active direction",
ylab="Second active direction",
zlab="Model output",
col=bob[mycol(y, length(bob))], size=0.8, type=c("s"))
png("figs/poly_2dplot.png", height=5, width=5, units="in", res=300)
bob <- RColorBrewer::brewer.pal(11, "RdBu")
plot(X%*%W[,1], y, xlab="First active direction", ylab="Model output",
pch=21, bg=bob[mycol(y, length(bob))], col="black")
dev.off()
if(require(rgl)){
options(rgl.printRglwidget = TRUE)
png("figs/poly_3dplot.png", height=5, width=5, units="in", res=300)
plot3d(X%*%W[,1], X%*%W[,2], y,
xlab="First active direction",
ylab="Second active direction",
zlab="Model output",
col=bob[mycol(y, length(bob))], size=0.8, type=c("s"))
dev.off()
}
png("figs/poly_3dplot.png", height=5, width=5, units="in", res=300)
plot3d(X%*%W[,1], X%*%W[,2], y,
xlab="First active direction",
ylab="Second active direction",
zlab="Model output",
col=bob[mycol(y, length(bob))], size=0.8, type=c("s"))
dev.off()
options(rgl.printRglwidget = FALSE)
png("figs/poly_3dplot.png", height=5, width=5, units="in", res=300)
plot3d(X%*%W[,1], X%*%W[,2], y,
xlab="First active direction",
ylab="Second active direction",
zlab="Model output",
col=bob[mycol(y, length(bob))], size=0.8, type=c("s"))
dev.off()
options(rgl.printRglwidget = TRUE)
png("figs/poly_3dplot.png", height=5, width=5, units="in", res=300)
plot3d(X%*%W[,1], X%*%W[,2], y,
xlab="First active direction",
ylab="Second active direction",
zlab="Model output",
col=bob[mycol(y, length(bob))], size=0.8, type=c("s"))
dev.off()
2^7
