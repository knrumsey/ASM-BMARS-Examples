dj <- dj + w[j]*dj_tmp$y
#lines(theta_range_vec, dj_tmp$y, col=j)
}
d_bps <- d0 + dj
}
theta_range_vec <- seq(-1, 11, length.out=10000)
# Make a synthesis prediction at xstar using herding synthesis function
xstar <- runif(2)
mtrue <- duqling::lim_polynomial(xstar)
strue <- log(1.1 + xstar[1]*xstar[2])
q  <- rep(1/J, J)
c  <- 0.1
d  <- 1
d_bps <- get_d_bps(xstar, c=c, d=d, q, fit_full, fit_loo)
plot(theta_range_vec, d_bps, type='l', lwd=2, ylim=range(0, 3))
for(j in 1:J){
lines(density(y[[j]]), col=adjustcolor('gray', alpha.f=0.5))
}
lines(density(gen_theta(10000, xstar)), col='dodgerblue', lwd=2)
pred_full <- predict(fit_full, matrix(xstar, ncol=2))
m_star <- pred_full$mean
s_star <- sqrt(pred_full$nugs)
curve(dnorm(x, m_star, s_star), add=TRUE, col='orange', lty=2, lwd=2)
legend("topleft", c("BPS", "Base (GP)", "True"), col=c('black', 'orange', 'dodgerblue'), lwd=2, lty=c(1, 3, 1))
library(lhs)
library(duqling)
library(hetGP)
gen_theta <- function(n, x){
m <- duqling::lim_polynomial(x)
s <- log(1.1 + x[1]*x[2])
theta <- rnorm(n, m, s)
}
gen_theta_gamma <- function(n, x){
m <- duqling::lim_polynomial(x)
s <- log(1.1 + x[1]*x[2])
b <- m/s^2
a <- m*b
theta <- rgamma(n, a, b)
}
J <- 7
n <- 100
X <- maximinLHS(J, 2)
y <- list()
for(j in 1:J){
y[[j]] <- gen_theta(n, X[j,])
}
# Fit a full GP
XX <- apply(X, 2, function(zz) rep(zz, each=n))
yy <- unlist(y)
fit_full <- mleHetGP(XX, yy)
# Fit LOO GPs
fit_loo <- list()
for(j in 1:J){
ind <- (1 + n*(j-1)):(n*j)
XXj <- XX[-ind,]
yyj <- yy[-ind]
fit_loo[[j]] <- mleHetGP(XXj, yyj)
}
get_d_bps <- function(xstar, c, d, q, fit_full, fit_loo){
# get base distribution
pred_full <- predict(fit_full, matrix(xstar, ncol=2))
m_full <- pred_full$mean
s_full <- sqrt(pred_full$nugs)
theta_range_vec <- seq(-1, 11, length.out=10000)
# get e_j terms
e <- nu <- rep(NA, J)
for(j in 1:J){
pred_j <- predict(fit_loo[[j]], matrix(xstar, ncol=2))
m_j <- pred_j$mean
s_j <- sqrt(pred_j$nugs)
nu[j] <- pred_j$sd2
e[j] <- max(abs(pnorm(theta_range_vec, m_full, s_full) - pnorm(theta_range_vec, m_j, s_j)))
}
nu <- nu*mean(e)
cprime  <- c/(2*nu)
w <- q*(1 - d*exp(-cprime*e^2))
w <- pmax(w, 0) # make sure w isn't negative
w0 <- 1 - sum(w)
d0 <- w0*dnorm(theta_range_vec, m_full, s_full)
dj <- rep(0, length(theta_range_vec))
#plot(theta_range_vec, d0/w0, type='l', col='blue')
for(j in 1:J){
dj_tmp <- density(y[[j]],
from=min(theta_range_vec), to=max(theta_range_vec),
n=length(theta_range_vec))
dj <- dj + w[j]*dj_tmp$y
#lines(theta_range_vec, dj_tmp$y, col=j)
}
d_bps <- d0 + dj
}
theta_range_vec <- seq(-1, 11, length.out=10000)
# Make a synthesis prediction at xstar using herding synthesis function
xstar <- runif(2)
mtrue <- duqling::lim_polynomial(xstar)
strue <- log(1.1 + xstar[1]*xstar[2])
q  <- rep(1/J, J)
c  <- 0.1
d  <- 1
d_bps <- get_d_bps(xstar, c=c, d=d, q, fit_full, fit_loo)
plot(theta_range_vec, d_bps, type='l', lwd=2, ylim=range(0, 3))
for(j in 1:J){
lines(density(y[[j]]), col=adjustcolor('gray', alpha.f=0.5))
}
lines(density(gen_theta(10000, xstar)), col='dodgerblue', lwd=2)
pred_full <- predict(fit_full, matrix(xstar, ncol=2))
m_star <- pred_full$mean
s_star <- sqrt(pred_full$nugs)
curve(dnorm(x, m_star, s_star), add=TRUE, col='orange', lty=2, lwd=2)
legend("topleft", c("BPS", "Base (GP)", "True"), col=c('black', 'orange', 'dodgerblue'), lwd=2, lty=c(1, 3, 1))
c  <- 0.5
d  <- 1
d_bps <- get_d_bps(xstar, c=c, d=d, q, fit_full, fit_loo)
plot(theta_range_vec, d_bps, type='l', lwd=2, ylim=range(0, 3))
for(j in 1:J){
lines(density(y[[j]]), col=adjustcolor('gray', alpha.f=0.5))
}
lines(density(gen_theta(10000, xstar)), col='dodgerblue', lwd=2)
pred_full <- predict(fit_full, matrix(xstar, ncol=2))
c  <- 1
d  <- 1
d_bps <- get_d_bps(xstar, c=c, d=d, q, fit_full, fit_loo)
plot(theta_range_vec, d_bps, type='l', lwd=2, ylim=range(0, 3))
for(j in 1:J){
lines(density(y[[j]]), col=adjustcolor('gray', alpha.f=0.5))
}
lines(density(gen_theta(10000, xstar)), col='dodgerblue', lwd=2)
library(lhs)
library(duqling)
library(hetGP)
gen_theta <- function(n, x){
m <- duqling::lim_polynomial(x)
s <- log(1.1 + x[1]*x[2])
theta <- rnorm(n, m, s)
}
gen_theta_gamma <- function(n, x){
m <- duqling::lim_polynomial(x)
s <- log(1.1 + x[1]*x[2])
b <- m/s^2
a <- m*b
theta <- rgamma(n, a, b)
}
J <- 7
n <- 100
X <- maximinLHS(J, 2)
y <- list()
for(j in 1:J){
y[[j]] <- gen_theta(n, X[j,])
}
# Fit a full GP
XX <- apply(X, 2, function(zz) rep(zz, each=n))
yy <- unlist(y)
fit_full <- mleHetGP(XX, yy)
# Fit LOO GPs
fit_loo <- list()
for(j in 1:J){
ind <- (1 + n*(j-1)):(n*j)
XXj <- XX[-ind,]
yyj <- yy[-ind]
fit_loo[[j]] <- mleHetGP(XXj, yyj)
}
get_d_bps <- function(xstar, c, d, q, fit_full, fit_loo){
# get base distribution
pred_full <- predict(fit_full, matrix(xstar, ncol=2))
m_full <- pred_full$mean
s_full <- sqrt(pred_full$nugs)
theta_range_vec <- seq(-1, 11, length.out=10000)
# get e_j terms
e <- nu <- rep(NA, J)
for(j in 1:J){
pred_j <- predict(fit_loo[[j]], matrix(xstar, ncol=2))
m_j <- pred_j$mean
s_j <- sqrt(pred_j$nugs)
nu[j] <- pred_j$sd2
e[j] <- max(abs(pnorm(theta_range_vec, m_full, s_full) - pnorm(theta_range_vec, m_j, s_j)))
}
nu <- nu*mean(e)
cprime  <- c/(2*nu)
w <- q*(1 - d*exp(-cprime*e^2))
w <- pmax(w, 0) # make sure w isn't negative
w0 <- 1 - sum(w)
d0 <- w0*dnorm(theta_range_vec, m_full, s_full)
dj <- rep(0, length(theta_range_vec))
#plot(theta_range_vec, d0/w0, type='l', col='blue')
for(j in 1:J){
dj_tmp <- density(y[[j]],
from=min(theta_range_vec), to=max(theta_range_vec),
n=length(theta_range_vec))
dj <- dj + w[j]*dj_tmp$y
#lines(theta_range_vec, dj_tmp$y, col=j)
}
d_bps <- d0 + dj
}
theta_range_vec <- seq(-1, 11, length.out=10000)
# Make a synthesis prediction at xstar using herding synthesis function
xstar <- runif(2)
mtrue <- duqling::lim_polynomial(xstar)
strue <- log(1.1 + xstar[1]*xstar[2])
q  <- rep(1/J, J)
c  <- 5
d  <- 1
d_bps <- get_d_bps(xstar, c=c, d=d, q, fit_full, fit_loo)
plot(theta_range_vec, d_bps, type='l', lwd=2, ylim=range(0, 3))
for(j in 1:J){
lines(density(y[[j]]), col=adjustcolor('gray', alpha.f=0.5))
}
lines(density(gen_theta(10000, xstar)), col='dodgerblue', lwd=2)
pred_full <- predict(fit_full, matrix(xstar, ncol=2))
m_star <- pred_full$mean
s_star <- sqrt(pred_full$nugs)
curve(dnorm(x, m_star, s_star), add=TRUE, col='orange', lty=2, lwd=2)
legend("topleft", c("BPS", "Base (GP)", "True"), col=c('black', 'orange', 'dodgerblue'), lwd=2, lty=c(1, 3, 1))
library(lhs)
library(duqling)
library(hetGP)
gen_theta <- function(n, x){
m <- duqling::lim_polynomial(x)
s <- log(1.1 + x[1]*x[2])
theta <- rnorm(n, m, s)
}
gen_theta_gamma <- function(n, x){
m <- duqling::lim_polynomial(x)
s <- log(1.1 + x[1]*x[2])
b <- m/s^2
a <- m*b
theta <- rgamma(n, a, b)
}
J <- 7
n <- 100
X <- maximinLHS(J, 2)
y <- list()
for(j in 1:J){
y[[j]] <- gen_theta(n, X[j,])
}
# Fit a full GP
XX <- apply(X, 2, function(zz) rep(zz, each=n))
yy <- unlist(y)
fit_full <- mleHetGP(XX, yy)
# Fit LOO GPs
fit_loo <- list()
for(j in 1:J){
ind <- (1 + n*(j-1)):(n*j)
XXj <- XX[-ind,]
yyj <- yy[-ind]
fit_loo[[j]] <- mleHetGP(XXj, yyj)
}
get_d_bps <- function(xstar, c, d, q, fit_full, fit_loo){
# get base distribution
pred_full <- predict(fit_full, matrix(xstar, ncol=2))
m_full <- pred_full$mean
s_full <- sqrt(pred_full$nugs)
theta_range_vec <- seq(-1, 11, length.out=10000)
# get e_j terms
e <- nu <- rep(NA, J)
for(j in 1:J){
pred_j <- predict(fit_loo[[j]], matrix(xstar, ncol=2))
m_j <- pred_j$mean
s_j <- sqrt(pred_j$nugs)
nu[j] <- pred_j$sd2
e[j] <- max(abs(pnorm(theta_range_vec, m_full, s_full) - pnorm(theta_range_vec, m_j, s_j)))
}
nu <- nu*mean(e)
cprime  <- c/(2*nu)
w <- q*(1 - d*exp(-cprime*e^2))
w <- pmax(w, 0) # make sure w isn't negative
w0 <- 1 - sum(w)
d0 <- w0*dnorm(theta_range_vec, m_full, s_full)
dj <- rep(0, length(theta_range_vec))
#plot(theta_range_vec, d0/w0, type='l', col='blue')
for(j in 1:J){
dj_tmp <- density(y[[j]],
from=min(theta_range_vec), to=max(theta_range_vec),
n=length(theta_range_vec))
dj <- dj + w[j]*dj_tmp$y
#lines(theta_range_vec, dj_tmp$y, col=j)
}
d_bps <- d0 + dj
}
theta_range_vec <- seq(-1, 11, length.out=10000)
# Make a synthesis prediction at xstar using herding synthesis function
xstar <- runif(2)
mtrue <- duqling::lim_polynomial(xstar)
strue <- log(1.1 + xstar[1]*xstar[2])
q  <- rep(1/J, J)
c  <- 5
d  <- 1
d_bps <- get_d_bps(xstar, c=c, d=d, q, fit_full, fit_loo)
plot(theta_range_vec, d_bps, type='l', lwd=2, ylim=range(0, 3))
for(j in 1:J){
lines(density(y[[j]]), col=adjustcolor('gray', alpha.f=0.5))
}
lines(density(gen_theta(10000, xstar)), col='dodgerblue', lwd=2)
pred_full <- predict(fit_full, matrix(xstar, ncol=2))
m_star <- pred_full$mean
s_star <- sqrt(pred_full$nugs)
curve(dnorm(x, m_star, s_star), add=TRUE, col='orange', lty=2, lwd=2)
legend("topleft", c("BPS", "Base (GP)", "True"), col=c('black', 'orange', 'dodgerblue'), lwd=2, lty=c(1, 3, 1))
library(lhs)
library(duqling)
library(hetGP)
gen_theta <- function(n, x){
m <- duqling::lim_polynomial(x)
s <- log(1.1 + x[1]*x[2])
theta <- rnorm(n, m, s)
}
gen_theta_gamma <- function(n, x){
m <- duqling::lim_polynomial(x)
s <- log(1.1 + x[1]*x[2])
b <- m/s^2
a <- m*b
theta <- rgamma(n, a, b)
}
J <- 7
n <- 100
X <- maximinLHS(J, 2)
y <- list()
for(j in 1:J){
y[[j]] <- gen_theta(n, X[j,])
}
# Fit a full GP
XX <- apply(X, 2, function(zz) rep(zz, each=n))
yy <- unlist(y)
fit_full <- mleHetGP(XX, yy)
# Fit LOO GPs
fit_loo <- list()
for(j in 1:J){
ind <- (1 + n*(j-1)):(n*j)
XXj <- XX[-ind,]
yyj <- yy[-ind]
fit_loo[[j]] <- mleHetGP(XXj, yyj)
}
get_d_bps <- function(xstar, c, d, q, fit_full, fit_loo){
# get base distribution
pred_full <- predict(fit_full, matrix(xstar, ncol=2))
m_full <- pred_full$mean
s_full <- sqrt(pred_full$nugs)
theta_range_vec <- seq(-1, 11, length.out=10000)
# get e_j terms
e <- nu <- rep(NA, J)
for(j in 1:J){
pred_j <- predict(fit_loo[[j]], matrix(xstar, ncol=2))
m_j <- pred_j$mean
s_j <- sqrt(pred_j$nugs)
nu[j] <- pred_j$sd2
e[j] <- max(abs(pnorm(theta_range_vec, m_full, s_full) - pnorm(theta_range_vec, m_j, s_j)))
}
nu <- nu*mean(e)
cprime  <- c/(2*nu)
w <- q*(1 - d*exp(-cprime*e^2))
w <- pmax(w, 0) # make sure w isn't negative
w0 <- 1 - sum(w)
d0 <- w0*dnorm(theta_range_vec, m_full, s_full)
dj <- rep(0, length(theta_range_vec))
#plot(theta_range_vec, d0/w0, type='l', col='blue')
for(j in 1:J){
dj_tmp <- density(y[[j]],
from=min(theta_range_vec), to=max(theta_range_vec),
n=length(theta_range_vec))
dj <- dj + w[j]*dj_tmp$y
#lines(theta_range_vec, dj_tmp$y, col=j)
}
d_bps <- d0 + dj
}
theta_range_vec <- seq(-1, 11, length.out=10000)
# Make a synthesis prediction at xstar using herding synthesis function
xstar <- runif(2)
mtrue <- duqling::lim_polynomial(xstar)
strue <- log(1.1 + xstar[1]*xstar[2])
q  <- rep(1/J, J)
c  <- 5
d  <- 1
d_bps <- get_d_bps(xstar, c=c, d=d, q, fit_full, fit_loo)
plot(theta_range_vec, d_bps, type='l', lwd=2, ylim=range(0, 3))
for(j in 1:J){
lines(density(y[[j]]), col=adjustcolor('gray', alpha.f=0.5))
}
lines(density(gen_theta(10000, xstar)), col='dodgerblue', lwd=2)
pred_full <- predict(fit_full, matrix(xstar, ncol=2))
m_star <- pred_full$mean
s_star <- sqrt(pred_full$nugs)
curve(dnorm(x, m_star, s_star), add=TRUE, col='orange', lty=2, lwd=2)
legend("topleft", c("BPS", "Base (GP)", "True"), col=c('black', 'orange', 'dodgerblue'), lwd=2, lty=c(1, 3, 1))
library(lhs)
library(duqling)
library(hetGP)
gen_theta <- function(n, x){
m <- duqling::lim_polynomial(x)
s <- log(1.1 + x[1]*x[2])
theta <- rnorm(n, m, s)
}
gen_theta_gamma <- function(n, x){
m <- duqling::lim_polynomial(x)
s <- log(1.1 + x[1]*x[2])
b <- m/s^2
a <- m*b
theta <- rgamma(n, a, b)
}
J <- 7
n <- 100
X <- maximinLHS(J, 2)
y <- list()
for(j in 1:J){
y[[j]] <- gen_theta(n, X[j,])
}
# Fit a full GP
XX <- apply(X, 2, function(zz) rep(zz, each=n))
yy <- unlist(y)
fit_full <- mleHetGP(XX, yy)
# Fit LOO GPs
fit_loo <- list()
for(j in 1:J){
ind <- (1 + n*(j-1)):(n*j)
XXj <- XX[-ind,]
yyj <- yy[-ind]
fit_loo[[j]] <- mleHetGP(XXj, yyj)
}
get_d_bps <- function(xstar, c, d, q, fit_full, fit_loo){
# get base distribution
pred_full <- predict(fit_full, matrix(xstar, ncol=2))
m_full <- pred_full$mean
s_full <- sqrt(pred_full$nugs)
theta_range_vec <- seq(-1, 11, length.out=10000)
# get e_j terms
e <- nu <- rep(NA, J)
for(j in 1:J){
pred_j <- predict(fit_loo[[j]], matrix(xstar, ncol=2))
m_j <- pred_j$mean
s_j <- sqrt(pred_j$nugs)
nu[j] <- pred_j$sd2
e[j] <- max(abs(pnorm(theta_range_vec, m_full, s_full) - pnorm(theta_range_vec, m_j, s_j)))
}
nu <- nu*mean(e)
cprime  <- c/(2*nu)
w <- q*(1 - d*exp(-cprime*e^2))
w <- pmax(w, 0) # make sure w isn't negative
w0 <- 1 - sum(w)
d0 <- w0*dnorm(theta_range_vec, m_full, s_full)
dj <- rep(0, length(theta_range_vec))
#plot(theta_range_vec, d0/w0, type='l', col='blue')
for(j in 1:J){
dj_tmp <- density(y[[j]],
from=min(theta_range_vec), to=max(theta_range_vec),
n=length(theta_range_vec))
dj <- dj + w[j]*dj_tmp$y
#lines(theta_range_vec, dj_tmp$y, col=j)
}
d_bps <- d0 + dj
}
theta_range_vec <- seq(-1, 11, length.out=10000)
# Make a synthesis prediction at xstar using herding synthesis function
xstar <- runif(2)
mtrue <- duqling::lim_polynomial(xstar)
strue <- log(1.1 + xstar[1]*xstar[2])
q  <- rep(1/J, J)
c  <- 5
d  <- 1
d_bps <- get_d_bps(xstar, c=c, d=d, q, fit_full, fit_loo)
plot(theta_range_vec, d_bps, type='l', lwd=2, ylim=range(0, 3))
for(j in 1:J){
lines(density(y[[j]]), col=adjustcolor('gray', alpha.f=0.5))
}
lines(density(gen_theta(10000, xstar)), col='dodgerblue', lwd=2)
pred_full <- predict(fit_full, matrix(xstar, ncol=2))
m_star <- pred_full$mean
s_star <- sqrt(pred_full$nugs)
curve(dnorm(x, m_star, s_star), add=TRUE, col='orange', lty=2, lwd=2)
legend("topleft", c("BPS", "Base (GP)", "True"), col=c('black', 'orange', 'dodgerblue'), lwd=2, lty=c(1, 3, 1))
y <- apply(X, 1, duqling::friedman)
n <- 1000
p <- 5
X <- lhs::maximinLHS(n, p)
y <- apply(X, 1, duqling::friedman)
var(y)
library(BASS)
mod <- bass(X, y, birth.type="coinflip")
?bass
sob <- sobol(mod)
plot(sob)
sob$S[1:5]
apply(sob$S, 2, mean)
apply(sob$S, 2, mean)[1:5]
SS <- apply(sob$S, 2, mean)[1:5]
TT <- apply(sob$T, 2, mean)
round(SS, 3)
round(TT, 3)
Sh <- shapley(sob)
Sh
Sh <- shapley(sob, proportion=TRUE)
apply(Sh, 2, mean)
Sh <- apply(shap, 2, mean)
shap <- shapley(sob, proportion=TRUE)
SS <- apply(sob$S, 2, mean)[1:5]
TT <- apply(sob$T, 2, mean)
Sh <- apply(shap, 2, mean)
cbind(SS, TT, Sh)
round(cbind(SS, TT, Sh), 3)
stargazer::stargazer(round(cbind(SS, TT, Sh), 3), summary=FALSE, type="text")
sobS <- apply(sob$S, 2, mean)[1:5]
sobT <- apply(sob$T, 2, mean)
Shap <- apply(shap, 2, mean)
Tab <- round(cbind(sobS, sobT, Shap), 3)
stargazer::stargazer(Tab, summary=FALSE, type="text")
shapley_taylor(sob)
shapt = shapley_taylor(sob)
length(shapt)
boxplot(shapt[[1]])
shapley_taylor(sob, proportion=TRUE)
shapt = shapley_taylor(sob, proportion=TRUE)
apply(shapt[[1]], 2, mean)
round(apply(shapt[[1]], 2, mean), 3)
round(apply(shapt[[2]], 2, mean), 3)
round(apply(shapt[[3]], 2, mean), 3)
(apply(shapt[[3]], 2, mean)  )
